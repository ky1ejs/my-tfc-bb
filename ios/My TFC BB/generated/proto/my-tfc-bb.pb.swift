// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: my-tfc-bb.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Services_Mytfcbb_V1_GetDeliveriesFilterType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case uncollected // = 0
  case active // = 1
  case collected // = 2
  case search // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .uncollected
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .uncollected
    case 1: self = .active
    case 2: self = .collected
    case 3: self = .search
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .uncollected: return 0
    case .active: return 1
    case .collected: return 2
    case .search: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Services_Mytfcbb_V1_GetDeliveriesFilterType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Services_Mytfcbb_V1_GetDeliveriesFilterType] = [
    .uncollected,
    .active,
    .collected,
    .search,
  ]
}

#endif  // swift(>=4.2)

enum Services_Mytfcbb_V1_PushPlatform: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ios // = 0
  case android // = 1
  case web // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .ios
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ios
    case 1: self = .android
    case 2: self = .web
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ios: return 0
    case .android: return 1
    case .web: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Services_Mytfcbb_V1_PushPlatform: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Services_Mytfcbb_V1_PushPlatform] = [
    .ios,
    .android,
    .web,
  ]
}

#endif  // swift(>=4.2)

enum Services_Mytfcbb_V1_TokenEnv: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case production // = 0
  case staging // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .production
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .production
    case 1: self = .staging
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .production: return 0
    case .staging: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Services_Mytfcbb_V1_TokenEnv: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Services_Mytfcbb_V1_TokenEnv] = [
    .production,
    .staging,
  ]
}

#endif  // swift(>=4.2)

struct Services_Mytfcbb_V1_Delivery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var comment: String = String()

  var dateReceived: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _dateReceived ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_dateReceived = newValue}
  }
  /// Returns true if `dateReceived` has been explicitly set.
  var hasDateReceived: Bool {return self._dateReceived != nil}
  /// Clears the value of `dateReceived`. Subsequent reads from it will return its default value.
  mutating func clearDateReceived() {self._dateReceived = nil}

  var collectedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _collectedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_collectedAt = newValue}
  }
  /// Returns true if `collectedAt` has been explicitly set.
  var hasCollectedAt: Bool {return self._collectedAt != nil}
  /// Clears the value of `collectedAt`. Subsequent reads from it will return its default value.
  mutating func clearCollectedAt() {self._collectedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dateReceived: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _collectedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Services_Mytfcbb_V1_LogInRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var username: String = String()

  var password: String = String()

  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Services_Mytfcbb_V1_LogInResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Services_Mytfcbb_V1_GetDeliveriesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var filter: Services_Mytfcbb_V1_GetDeliveriesFilterType = .uncollected

  var searchTerm: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Services_Mytfcbb_V1_GetDeliveriesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deliveries: [Services_Mytfcbb_V1_Delivery] = []

  var collectedCount: Int32 = 0

  var uncollectedCount: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Services_Mytfcbb_V1_UpdatePushTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var platform: Services_Mytfcbb_V1_PushPlatform = .ios

  var env: Services_Mytfcbb_V1_TokenEnv = .production

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Services_Mytfcbb_V1_GetDeliveriesFilterType: @unchecked Sendable {}
extension Services_Mytfcbb_V1_PushPlatform: @unchecked Sendable {}
extension Services_Mytfcbb_V1_TokenEnv: @unchecked Sendable {}
extension Services_Mytfcbb_V1_Delivery: @unchecked Sendable {}
extension Services_Mytfcbb_V1_LogInRequest: @unchecked Sendable {}
extension Services_Mytfcbb_V1_LogInResponse: @unchecked Sendable {}
extension Services_Mytfcbb_V1_GetDeliveriesRequest: @unchecked Sendable {}
extension Services_Mytfcbb_V1_GetDeliveriesResponse: @unchecked Sendable {}
extension Services_Mytfcbb_V1_UpdatePushTokenRequest: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "services.mytfcbb.v1"

extension Services_Mytfcbb_V1_GetDeliveriesFilterType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "uncollected"),
    1: .same(proto: "active"),
    2: .same(proto: "collected"),
    3: .same(proto: "search"),
  ]
}

extension Services_Mytfcbb_V1_PushPlatform: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ios"),
    1: .same(proto: "android"),
    2: .same(proto: "web"),
  ]
}

extension Services_Mytfcbb_V1_TokenEnv: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "production"),
    1: .same(proto: "staging"),
  ]
}

extension Services_Mytfcbb_V1_Delivery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Delivery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "comment"),
    4: .standard(proto: "date_received"),
    5: .standard(proto: "collected_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._dateReceived) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._collectedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 3)
    }
    try { if let v = self._dateReceived {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._collectedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Services_Mytfcbb_V1_Delivery, rhs: Services_Mytfcbb_V1_Delivery) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs._dateReceived != rhs._dateReceived {return false}
    if lhs._collectedAt != rhs._collectedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Services_Mytfcbb_V1_LogInRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogInRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
    3: .standard(proto: "device_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Services_Mytfcbb_V1_LogInRequest, rhs: Services_Mytfcbb_V1_LogInRequest) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Services_Mytfcbb_V1_LogInResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogInResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Services_Mytfcbb_V1_LogInResponse, rhs: Services_Mytfcbb_V1_LogInResponse) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Services_Mytfcbb_V1_GetDeliveriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDeliveriesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
    2: .standard(proto: "search_term"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.filter) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.searchTerm) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.filter != .uncollected {
      try visitor.visitSingularEnumField(value: self.filter, fieldNumber: 1)
    }
    if !self.searchTerm.isEmpty {
      try visitor.visitSingularStringField(value: self.searchTerm, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Services_Mytfcbb_V1_GetDeliveriesRequest, rhs: Services_Mytfcbb_V1_GetDeliveriesRequest) -> Bool {
    if lhs.filter != rhs.filter {return false}
    if lhs.searchTerm != rhs.searchTerm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Services_Mytfcbb_V1_GetDeliveriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDeliveriesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deliveries"),
    2: .standard(proto: "collected_count"),
    3: .standard(proto: "uncollected_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.deliveries) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.collectedCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.uncollectedCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deliveries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deliveries, fieldNumber: 1)
    }
    if self.collectedCount != 0 {
      try visitor.visitSingularInt32Field(value: self.collectedCount, fieldNumber: 2)
    }
    if self.uncollectedCount != 0 {
      try visitor.visitSingularInt32Field(value: self.uncollectedCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Services_Mytfcbb_V1_GetDeliveriesResponse, rhs: Services_Mytfcbb_V1_GetDeliveriesResponse) -> Bool {
    if lhs.deliveries != rhs.deliveries {return false}
    if lhs.collectedCount != rhs.collectedCount {return false}
    if lhs.uncollectedCount != rhs.uncollectedCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Services_Mytfcbb_V1_UpdatePushTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdatePushTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platform"),
    2: .same(proto: "env"),
    3: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.env) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platform != .ios {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 1)
    }
    if self.env != .production {
      try visitor.visitSingularEnumField(value: self.env, fieldNumber: 2)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Services_Mytfcbb_V1_UpdatePushTokenRequest, rhs: Services_Mytfcbb_V1_UpdatePushTokenRequest) -> Bool {
    if lhs.platform != rhs.platform {return false}
    if lhs.env != rhs.env {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
